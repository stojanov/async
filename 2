#pragma once

#include <async/pch.h>

#include <iostream>

namespace async {

namespace detail {};

// V value should have equals operator, stongly encraged for V to be a pointer
// untill i can fix it
// when generic midpoint is ready this will be modified
template <std::integral K, typename V> class interval_map {
  public:
    using interval_t = std::pair<K, K>;
    using value_ref = V &;

  private:
    enum class interval_type { START, END };

    struct interval_entry {
        V value;
        interval_type type;
        K other_key_value;
    };

  public:
    void add_interval(const interval_t &interval, const V &value) {
        const auto &[start, end] = interval;

        const auto end_start = std::end(_mp_start);
        const auto end_end = std::end(_mp_end);

        auto start_entry = interval_entry{value, interval_type::START, end};
        auto end_entry = interval_entry{value, interval_type::END, start};

        auto lower_node_start = _mp_start.lower_bound(start);
        auto higher_node_end = _mp_end.lower_bound(end);

        // edge case, equals
        if (lower_node_start != end_start, lower_node_start->first > value) {
            const auto prev_start = lower_node_start->first;
            const auto prev_end = lower_node_start->first.other_key_value;

            if (prev_start > end) {
                // do nothing
            } else {
                if (prev_end > end) {
                    _mp_start.erase(prev_start);
                    _mp_start[end] = lower_node_start->second;
                } else {
                }
            }

        } else {
            const auto parent_end = lower_node_start->second.other_key_value;

            if (end > parent_end) {
                // mid section, remove parent end from end, signal end of that
                // range, own start is end
                _mp_end.erase(parent_end);
            } else {
                _mp_start[end] = lower_node_start->second;
            }

            _mp_start[start] = start_entry;
        }

        if (higher_node_end != end_end; higher_node_end->first < value) {
            // not contains, but inside maybe ?
        }
    }

    std::optional<V *> find_in_interval(const K &interval_value) {
        return std::nullopt;
    }

    void print() {
        std::cout << "START POINT MAP\n";

        auto type_str = [](interval_type t) {
            return t == interval_type::START ? "S" : "E";
        };

        for (auto &i : _mp) {
            std::cout << i.first << ": " << i.second.value << " :"
                      << type_str(i.second.type) << "\n";
        }
    }

  private:
    K _min_separator;
    std::map<K, interval_entry, std::less<K>> _mp_start;
    std::map<K, interval_entry, std::greater<K>> _mp_end;
};
} // namespace async
